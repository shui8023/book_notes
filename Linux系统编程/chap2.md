#About The Book

* LINUX系统编程
* [美]Robert Love 著
* 祝洪凯 李妹芳 付途 译
* 关于 Robert Love 是<\<Linux Kernel        Development\>>的作者，目前是google的工程师，对Linux内核和gnome做了很多贡献
* 第二章 文件I/O

***
* __文件描述符__(File Describe):是一个非负整数，使用C语言的int类型的表示，一个进程打开的文件个数默认的Soft Limit是1024,Hard Limit是4096,可以通过/proc/xxx/limits查看。也可以通过ulimit -a/-n 来查看。由于是用int表示fd，所以最大值是int表示的最大值。按照惯例，每个进程至少包含三个文件描述符：0,1,2。0：代表标准输入，1：代表标准输出，3：代表标准错误。Linux C使用三个宏来表示，分别是STDIN_FILENO,STDOUT_FILENO, STDERR_FILENO。关于Linux 下文件I/O都是基于文件描述符来实现的。

如何修改一个进程打开的最大文件数目,在/etc/security/limits.conf文件下添加下面代码，文件中详细介绍了如何修改
系统中的一些限制
```C
	* soft nofile 65535
	* soft nofile 65535
```
	Ps:*代表了所有的用户

***
* __open()__:int open(const char *name, )

***
* __write()__:write()的行为，当write()调用返回的时候，内核已经把数据从提供的缓冲区中拷贝到内核缓冲区，
但不保证数据已经写到目的地。实际上，write调用返回执行非常快，因此不可能保证数据已经写到目的地，处理器和硬盘
之间的性能差异使得这种情况非常明显。在用户空间发起write()系统调用时，Linux内核会做几项检查，然后直接把数据
拷贝到内核缓冲区，然后，在后台，内核收集所有这样的"脏"缓冲区(即存储的数据比磁盘的数据新)，然后进行排序优化，
然后把这些缓冲区写到磁盘上(writeback)。通过这种方式，write()可以频繁调用并立即返回。这种方式还支持内核把写操
作推迟到系统空闲时期，批处理很多写操作。但是这种延迟写有明显的确定，如果在写入内存之后，不能写入磁盘，导致
内存和磁盘的数据不能同步，在Linux处理的时候，会定时将页缓存写入到磁盘中，保证了内核和磁盘的一致性。

*** 
* __read()__:r

***
* __同步I/O__:

***

