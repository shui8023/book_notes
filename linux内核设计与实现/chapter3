						进程管理

1:进程就是处于执行期的程序以及相关资源的总称;
2:fork函数调用从内核返回两次，一次回到父进程，一次回到新产生的子进程;
3：进程退出执行后被设置为僵死状态，直到它的父进程调用wait()或者waitpid()为止;
4：内核把进程的列表存放在叫做任务队列的双向循环链表中，链表中的每一项的类型都是task_struct,称为进程描述符;
5:linux通过slab分配器分配task_struct结构，各个进程的task_struct存放在他们内核栈的尾端，这样做是为了让那么些像X86体系寄存器较少
只要通过栈指针就能计算他的位置，(这个是相对以前的2.6的内核版本)，但是现在slab分配器动态生成task_struct，所以只需在栈低或栈顶创建一
个新的结构体struct thread_info,寄存器较弱的体系结构不是引入thread_info结构唯一的原因，这个新建的机构在汇编代码中计算其偏移变的非常
容易;
6：进程描述符PID的最大默认值为32768short int的最大值，但是这个值可以增加到400百万，可以通过cat /proc/sys/kernel/pid_max查看其值;
7：进程的五种状态：1：运行---进程是可执行的，他或者正在执行，或者在运行队列中等待执行，2：可中断的，进程正在睡眠，等待某些条件的
达成，一旦这些条件达成，内核就会把进程状态设置为运行;3：不可中断的，除了就算是接受信号也不会被唤醒或者准备投入运行外，其他的状态与
可中断状态一样;4：被其他进程跟踪的进程，例如通过ptrace对调试程序进程跟踪;5：进程停止执行，应该是僵死吧
7：进程上下文：当一个程序执行了系统调用或者触发了某个异常，他就陷入了内核空间，此时，我们称内核代表进程执行并处于进程
上下文;
8：进程只有通过这些接口才能陷入内核执行，对内核的所有访问都必须通过这些接口;
9：所有进程都是PID为1的init进程的后代，内核在系统启动的最后阶段启动init进程，让进程读系统的初始化脚本，并执行其他的相关程序，
最后完成系统启动的整个进程;
10：linux采用了进程创建分解为两个单独的函数去执行，fork()和exec(),fork函数首先拷贝当前进程创建一个子进程，子进程与当前父进程的
区别仅仅在于pid ppid和某些资源和统计量
11：写时拷贝：fork()写时拷贝是一中可以推迟甚至免于拷贝数据的技术，内核此时不用复制整个进程地址空间，而是让父进程和子进程共享同
一个拷贝只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝，资源的复制只有在需要写入的时候才进行，在此之前，
只是以只读的
方式共享;
12:fork()：linux通过clone系统调用，这个调用通过一系列的参数标示指示父，子进程需要共享的资源;
13:vfork(),除了不拷贝父进程的页表项外，不拷贝页表是为了共享地址空间;
14：进程的终结，当一个进程终结时，内核必须释放它所占的所有的资源
15:线程是正在进程中活动的对象，每个线程都拥有一个独立的程序计数器，进程栈和一组进程寄存器;内核调度的对象是线程;
16：线程实现的机制，该机制提供了同一程序内共享内存地址空间运行的一组线程，这个线程还可以共享打开的文件和其他的资源，从linux内核分析
，它并没有线程这个概念，线程仅仅被视为一个与其他进程共享某些资源的进程，每一个线程都拥有唯一隶属于自己的task_struct，所以在内核
空间里面，它看起来像是一个普通的进程。进程是资源分配最小的单位，线程是程序执行的最小单位;
17：线程与进程的区别，进程由自己独立的地址空间，线程没有没有自己独立的内存地址空间，同一个进程内的线程共享内存进程的地址空间;
18：内核线程：内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL），他们在内核空间运行，从来不切换到用户空间去;
19：进程终结：一般来说：进程的析构是自身引起的，它发生在进程调用exit（）系统调用之后，即可能显示的调用这个系统调用，也可能隐式的从某个程序的主函数返回，当进程接受它既不能处理也不能忽略的信号或异常时，它还可能被动的终结，都是靠do_exit()来完成;
20：在调用了do_exit()之后，尽管线程已经僵死不能在运行了。但是系统还保留了它的进程描述符，这样做的是可以让系统有办法在子进程终结
后能获得他的信息，进程终结所需的清理共工作和进程描述符的删除被分开执行，wait函数标准动作是挂起调用它的进程，直到其中的一个子进程
推出;
21：如果父进程在子进程之前推出，必须有机制来保证子进程能找到一个新的父亲， 否则这些为孤儿的进程会在退出的永远处于僵死状态，解决方
法是在当前线程组内找到一个线程作为父亲，如果不行就让init做他们父亲;


