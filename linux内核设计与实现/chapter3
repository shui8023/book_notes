						进程管理

1:进程就是处于执行期的程序以及相关资源的总称;
2:fork函数调用从内核返回两次，一次回到父进程，一次回到新产生的子进程;
3：进程退出执行后被设置为僵死状态，直到它的父进程调用wait()或者waitpid()为止;
4：内核把进程的列表存放在叫做任务队列的双向循环链表中，链表中的每一项的类型都是task_struct,称为进程描述符;
5:linux通过slab分配器分配task_struct结构，各个进程的task_struct存放在他们内核栈的尾端，这样做是为了让那么些像X86体系寄存器较少
只要通过栈指针就能计算他的位置，(这个是相对以前的2.6的内核版本)，但是现在slab分配器动态生成task_struct，所以只需在栈低或栈顶创建一
个新的结构体struct thread_info,寄存器较弱的体系结构不是引入thread_info结构唯一的原因，这个新建的机构在汇编代码中计算其偏移变的非常
容易;
6：进程描述符PID的最大默认值为32768short int的最大值，但是这个值可以增加到400百万，可以通过cat /proc/sys/kernel/pid_max查看其值;
7：进程的五种状态：1：运行---进程是可执行的，他或者正在执行，或者在运行队列中等待执行，2：可中断的，进程正在睡眠，等待某些条件的
达成，一旦这些条件达成，内核就会把进程状态设置为运行;3：不可中断的，除了就算是接受信号也不会被唤醒或者准备投入运行外，其他的状态与
可中断状态一样;4：被其他进程跟踪的进程，例如通过ptrace对调试程序进程跟踪;5：进程停止执行，应该是僵死吧
7：进程上下文：当一个程序执行了系统调用或者触发了某个异常，他就陷入了内核空间，此时，我们称内核代表进程执行并处于进程
上下文;
8：进程只有通过这些接口才能陷入内核执行，对内核的所有访问都必须通过这些接口;
9：所有进程都是PID为1的init进程的后代，内核在系统启动的最后阶段启动init进程，让进程读系统的初始化脚本，并执行其他的相关程序，
最后完成系统启动的整个进程;
10：linux采用了进程创建分解为两个单独的函数去执行，fork()和exec(),fork函数首先拷贝当前进程创建一个子进程，子进程与当前父进程的
区别仅仅在于pid ppid和某些资源和统计量
11：写时拷贝：fork()写时拷贝是一中可以推迟甚至免于拷贝数据的技术，内核此时不用复制整个进程地址空间，而是让父进程和子进程共享同
一个拷贝只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝，资源的复制只有在需要写入的时候才进行，在此之前，
只是以只读的
方式共享;
12:fork()：linux通过clone系统调用，这个调用通过一系列的参数标示指示父，子进程需要共享的资源;
13:vfork(),除了不拷贝父进程的页表项外，不拷贝页表是为了共享地址空间;
14：进程的终结，当一个进程终结时，内核必须释放它所占的所有的资源


